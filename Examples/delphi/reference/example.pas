(* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- *)

unit example;


{$define example_FUNCTION_WRAPPER}


{$define example_CLASS_WRAPPER}

interface

uses 
     Classes,
     SysUtils;


//type PDouble = ^double;


	type  
		Pdouble=^double;
		doubleArray = array[0..(MaxInt div sizeof(double))-1] of double;
		PdoubleArray = ^doubleArray;



	type  
		Pcardinal=^cardinal;
		cardinalArray = array[0..(MaxInt div sizeof(cardinal))-1] of cardinal;
		PcardinalArray = ^cardinalArray;



	type  
		CFILE=type Pointer;
		CFILEArray = array[0..(MaxInt div sizeof(CFILE))-1] of CFILE;
		PCFILEArray = ^CFILEArray;


type

Vector = type pointer;
PVectorArray = ^VectorArray_;
VectorArray_=array[0..(MaxInt div sizeof(Vector))-1] of Vector;

type

VectorArray = type pointer;
PVectorArrayArray = ^VectorArrayArray_;
VectorArrayArray_=array[0..(MaxInt div sizeof(VectorArray))-1] of VectorArray;

type
	Psize_t = ^Cardinal;


function New_Vector (x, y, z: Double): Vector; stdcall;

procedure Delete_Vector ( self: Vector); stdcall;

function Vector_print ( self: Vector): PChar; stdcall;

function Addv ( a, b: Vector): Vector; stdcall;

function New_VectorArray (maxsize: Integer): VectorArray; stdcall;

procedure Delete_VectorArray ( self: VectorArray); stdcall;

function VectorArray_size ( self: VectorArray): Integer; stdcall;

function VectorArray__get ( self: VectorArray;
index: Integer): Vector; stdcall;

procedure VectorArray__set ( self: VectorArray;
index: Integer;
 a: Vector); stdcall;

{$ifdef example_CLASS_WRAPPER}

type

  TVector = class (TObject, IUnknown)

  private
    FCObjPtr : Vector;
    FOwnCObjPtr : boolean;

  protected
	procedure SetCObjPtr(Value : Vector);
  // IUnknown
    function _AddRef : integer; stdcall;
    function _Release: integer; stdcall;
    function QueryInterface(const GUID:TGUID; out Intf): HRESULT; stdcall;
 public

    constructor Create; overload; virtual;
    constructor Create(CObj:Vector; OwnObj:boolean); overload; 

    constructor Create ( x: Double;  y: Double;  z: Double);overload; 

    function print (): PChar;

    destructor Destroy; override;
  
  public  
    property CObjPtr : Vector read FCObjPtr write SetCObjPtr;
    property OwnCObjPtr : boolean read FOwnCObjPtr  write FOwnCObjPtr ;

  end;


  TVectorArray = class (TObject, IUnknown)

  private
    FCObjPtr : VectorArray;
    FOwnCObjPtr : boolean;

  protected
	procedure SetCObjPtr(Value : VectorArray);
  // IUnknown
    function _AddRef : integer; stdcall;
    function _Release: integer; stdcall;
    function QueryInterface(const GUID:TGUID; out Intf): HRESULT; stdcall;
 public

    constructor Create; overload; virtual;
    constructor Create(CObj:VectorArray; OwnObj:boolean); overload; 

    constructor Create ( maxsize: Integer);overload; 

    function size (): Integer;

    function _get ( index: Integer): TVector;

    procedure _set ( index: Integer; var a: TVector);

    destructor Destroy; override;
  
  public  
    property CObjPtr : VectorArray read FCObjPtr write SetCObjPtr;
    property OwnCObjPtr : boolean read FOwnCObjPtr  write FOwnCObjPtr ;

  end;


{$endif} //example_CLASS_WRAPPER

{$ifdef example_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //example_FUNCTION_WRAPPER

implementation


const __DLLNAME= 'example.dll';


const __WRAPDLLNAME= 'example.dll';


function New_Vector (x, y, z: Double): Vector; stdcall; external __DLLNAME name 'Delphi_new_Vector';

procedure Delete_Vector ( self: Vector); stdcall; external __DLLNAME name 'Delphi_delete_Vector';

function Vector_print ( self: Vector): PChar; stdcall; external __DLLNAME name 'Delphi_Vector_print';

function Addv ( a, b: Vector): Vector; stdcall; external __DLLNAME name 'Delphi_addv';

function New_VectorArray (maxsize: Integer): VectorArray; stdcall; external __DLLNAME name 'Delphi_new_VectorArray';

procedure Delete_VectorArray ( self: VectorArray); stdcall; external __DLLNAME name 'Delphi_delete_VectorArray';

function VectorArray_size ( self: VectorArray): Integer; stdcall; external __DLLNAME name 'Delphi_VectorArray_size';

function VectorArray__get ( self: VectorArray;
index: Integer): Vector; stdcall; external __DLLNAME name 'Delphi_VectorArray__get';

procedure VectorArray__set ( self: VectorArray;
index: Integer;
 a: Vector); stdcall; external __DLLNAME name 'Delphi_VectorArray__set';

{$ifdef example_FUNCTION_WRAPPER}

// Functions Wrapper 


{$endif} //example_FUNCTION_WRAPPER

{$ifdef example_CLASS_WRAPPER}

constructor TVector.Create ( x: Double;  y: Double;  z: Double);

begin

  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := example.New_Vector(x, y, z);

end;

function TVector.print (): PChar;

begin

  assert(FCObjPtr <> nil);
  Result := example.Vector_print(Self.FCObjPtr) ;

end;


function TVector._AddRef : integer;
begin
   Result := -1;
end;

function TVector._Release: integer;
begin
   Result := -1;
end;

function TVector.QueryInterface(const GUID:TGUID; out Intf): HRESULT;
begin
   if GetInterface(GUID, Intf) then
      Result := S_OK
   else
      Result := S_FALSE	;
end; 
 
constructor TVector.Create; 
begin
  inherited Create;
  FCObjPtr := nil;
  FOwnCObjPtr := true
end;

constructor TVector.Create(CObj:Vector; OwnObj:boolean); 
begin
  inherited Create;
  FCObjPtr := CObj;
  FOwnCObjPtr := OwnObj
end;


destructor TVector.Destroy; 
begin   
  if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
    example.delete_Vector(FCObjPtr);
    FOwnCObjPtr := false;
  end;
  FCObjPtr := nil; 
  inherited Destroy;
end;

procedure TVector.SetCObjPtr(Value : Vector);
begin
 
  if (Value <> FCObjPtr) then begin
	if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
		example.delete_Vector(FCObjPtr);
	end;
	FCObjPtr := Value;
  
  
  end;

end;


constructor TVectorArray.Create ( maxsize: Integer);

begin

  inherited Create;
  FOwnCObjPtr := true;
   FCObjPtr := example.New_VectorArray(maxsize);

end;

function TVectorArray.size (): Integer;

begin

  assert(FCObjPtr <> nil);
  Result := example.VectorArray_size(Self.FCObjPtr) ;

end;

function TVectorArray._get ( index: Integer): TVector;

begin

  assert(FCObjPtr <> nil);
 
    Result := TVector.Create(example.VectorArray__get(Self.FCObjPtr, index), false);
;

end;

procedure TVectorArray._set ( index: Integer; var a: TVector);
var arg2:Vector;

begin

  assert(FCObjPtr <> nil);
  arg2 := a.CObjPtr;
 example.VectorArray__set(Self.FCObjPtr, index, arg2);

  a.CObjPtr := arg2 ;
end;


function TVectorArray._AddRef : integer;
begin
   Result := -1;
end;

function TVectorArray._Release: integer;
begin
   Result := -1;
end;

function TVectorArray.QueryInterface(const GUID:TGUID; out Intf): HRESULT;
begin
   if GetInterface(GUID, Intf) then
      Result := S_OK
   else
      Result := S_FALSE	;
end; 
 
constructor TVectorArray.Create; 
begin
  inherited Create;
  FCObjPtr := nil;
  FOwnCObjPtr := true
end;

constructor TVectorArray.Create(CObj:VectorArray; OwnObj:boolean); 
begin
  inherited Create;
  FCObjPtr := CObj;
  FOwnCObjPtr := OwnObj
end;


destructor TVectorArray.Destroy; 
begin   
  if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
    example.delete_VectorArray(FCObjPtr);
    FOwnCObjPtr := false;
  end;
  FCObjPtr := nil; 
  inherited Destroy;
end;

procedure TVectorArray.SetCObjPtr(Value : VectorArray);
begin
 
  if (Value <> FCObjPtr) then begin
	if (FCObjPtr <> nil) and  FOwnCObjPtr then begin 
		example.delete_VectorArray(FCObjPtr);
	end;
	FCObjPtr := Value;
  
  
  end;

end;


{$endif} //example_CLASS_WRAPPER

initialization



// constant initialization



//initialization


finalization


//finalization


end.
